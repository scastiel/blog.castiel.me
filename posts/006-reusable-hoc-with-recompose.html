<!DOCTYPE html><html><head><title>Create reusable high-order React components with Recompose â€“ Another webdev blog</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="https://blog.castiel.me/css/app.css"><link rel="alternate" type="application/rss+xml" title="Another webdev blog" href="https://blog.castiel.me/rss.xml"></head><body><header class="blog-header"><h1 class="blog-title"><a href="https://blog.castiel.me/">Another webdev blog</a></h1><div class="blog-description"><p>I&#39;m <a href="https://twitter.com/scastiel">SÃ©bastien Castiel</a>, and I talk about web development and some other stuff.</p>
</div></header><article><header><h2><a href="https://blog.castiel.me/posts/006-reusable-hoc-with-recompose.html">Create reusable high-order React components with Recompose</a></h2><div class="infos"><time datetime="2018-01-22T18:19:00.000Z">Jan 22, 2018</time></div></header><div class="content"><p>Writing reusable components in React is something every React developer care about (or should care about). Wether itâ€™s to create a toolbox of styled components, to mutualize common behaviors, etc.</p>
<p>Although I frequently use high-order components (with <em>React-Redux</em> for instance), itâ€™s only recently that I heard about the great opportunity they offer to write reusable components more easilly, especially thanks to a great library: <a href="https://github.com/acdlite/recompose">Recompose</a>. Letâ€™s see how with a concrete and complete example.</p>
<!--readmore-->
<p>If youâ€™ve never heard of high-order components (HOC) before, just know that basically, a HOC is a function that takes a component definition (class or function) as parameter, and returns a new component definition, that adds some behavior to the first one. Itâ€™s actually the pattern <a href="https://en.wikipedia.org/wiki/Decorator_pattern"><em>Decorator</em></a>, applied to React components.</p>
<p>Reactâ€™s website has a <a href="https://reactjs.org/docs/higher-order-components.html">really complete page</a> if you want to know more about HOCs.</p>
<p>A really simple example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> addBorder = <span class="hljs-function"><span class="hljs-params">borderWidth</span> =&gt;</span> Component =&gt; <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">borderColor:</span> '<span class="hljs-attr">black</span>', <span class="hljs-attr">borderStyle:</span> '<span class="hljs-attr">solid</span>', <span class="hljs-attr">borderWidth</span> }}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...props</span>} /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
)

const MyText = <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

const MyTextWithBorder = addBorder(5)(MyText)</span>
</code></pre>
<p>Youâ€™ll get a component <code>MyTextWithBorder</code> that will show the text &quot;Hello!&quot; with a border of 5 pixels. Here, <code>addBorder</code> is what is called a high-order component.</p>
<p>Whatâ€™s the interest of HOC? Well a really useful pattern is to extract a behavior shared with several components into reusable functions. If you used React with Redux and React-Redux, you probably used the HOC <code>connect</code> to map state and actions to props.</p>
<p>As a complete example for this article, weâ€™ll use HOC to create a phone number input component, that will:</p>
<ul>
<li>accept only digits, parenthesis, dashes and spaces as input (when the user types them);</li>
<li>format the phone number when the user leaves the input (on <em>blur</em> event). (Weâ€™ll handle only North-American phone numbers: &quot;(514) 555-0199&quot;.)</li>
</ul>
<center><img src="/public/phoneNumberInput.gif" alt="Phone number input result"></center>

<p>Note that we suppose that our input will be controlled, i.e. will use <code>value</code> and <code>onChange</code> attributes to know the text to display and how to update it. We also want the value to contain only the phone number digits (&quot;5145550199&quot;), without caring about formatting, and therefor the <code>onChange</code> callback to be called with digits only (in <code>event.target.value</code>).</p>
<p>To make our HOC easier to write and maintain, weâ€™ll use the library <em>Recompose</em>, which offers a great number of utility functions to create HOC. Weâ€™ll see some of these in the article.</p>
<p>To develop our component, weâ€™ll create two reusable HOC, one for each of the two points above. This means weâ€™ll want our final component to defined as:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> PhoneNumberInput = formatPhoneNumber(
  forbidNonPhoneNumberCharacters(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &lt;input {...props} /&gt;)
)
</code></pre>
<p>This is a good place to introduce the first <em>Recompose</em> function weâ€™ll use: <code>compose</code>. It composes several HOC to merge them into one, so we can write something much clearer:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> PhoneNumberInput = compose(
  formatPhoneNumber,
  forbidNonPhoneNumberCharacters
)(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &lt;input {...props} /&gt;)
</code></pre>
<p>And because weâ€™ll want our HOC to be as reusable as possible (to format something other than phone numbers for instance), weâ€™ll make them more generic:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Only keep digits, spaces, dashes and parenthesis</span>
<span class="hljs-keyword">const</span> forbiddenCharactersInPhoneNumber = <span class="hljs-regexp">/[^\d\s\-()]/g</span>

<span class="hljs-comment">// '5145551234' =&gt; '(514) 555-1234'</span>
<span class="hljs-keyword">const</span> formatPhoneNumber = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>
  value.replace(<span class="hljs-regexp">/^(\d{3})(\d{3})(\d{4})$/</span>, <span class="hljs-string">'($1) $2-$3'</span>)

<span class="hljs-comment">// '(514) 555-1234' =&gt; '5145551234'</span>
<span class="hljs-keyword">const</span> parsePhoneNumber = <span class="hljs-function"><span class="hljs-params">formattedPhoneNumber</span> =&gt;</span>
  formattedPhoneNumber.replace(<span class="hljs-regexp">/[^\d]/g</span>, <span class="hljs-string">''</span>).slice(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)

<span class="hljs-keyword">const</span> PhoneNumberInput = compose(
  formatInputValue({
    <span class="hljs-attr">formatValue</span>: formatPhoneNumber,
    <span class="hljs-attr">parseValue</span>: parsePhoneNumber
  }),
  forbidCharacters(forbiddenCharactersInPhoneNumber)
)(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &lt;input {...props} /&gt;)
</code></pre>
<p>Can you already see how this will become awesome, if we can reuse only our two HOC to format money amounts, social security numbers, and everything else, just by using the right parameters? ðŸ˜‰</p>
<p>The really interesting point is that here I use the base <code>&lt;input&gt;</code> component, but we could also use any component, as long as it uses <code>value</code>, <code>onChange</code> and <code>onBlur</code>. So we can imagine using our phone number input with React Native, or Material-UI, etc.</p>
<p>Okay, now comes the important part, writing our two HOC using Recompose functions.</p>
<h2 id="first-hoc-only-accept-some-characters">First HOC: only accept some characters</h2>
<p>The idea here is that when the input value is changed (<code>onChange</code> event), weâ€™ll intercept this event to remove every forbidden characters from the value, then call parent <code>onChange</code> with the clean value.</p>
<p>Here weâ€™ll use <code>withHandlers</code> function to add new event handlers as props to the encapsulated component. The good thing is that we have access to our component props (here weâ€™ll use <code>onChange</code>) to create our handler:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> forbidCharacters = <span class="hljs-function"><span class="hljs-params">forbiddenCharsRegexp</span> =&gt;</span>
  withHandlers({
    <span class="hljs-attr">onChange</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> event =&gt; {
      <span class="hljs-comment">// Remember `onChange` prop is not required (even if</span>
      <span class="hljs-comment">// here nothing would happen if itÂ´s not defined).</span>
      <span class="hljs-keyword">if</span> (props.onChange) {
        <span class="hljs-keyword">const</span> value = event.target.value
        <span class="hljs-keyword">const</span> cleanValue = value.replace(forbiddenCharsRegexp, <span class="hljs-string">''</span>)
        <span class="hljs-comment">// We donâ€™t mutate original event, but we clone it and</span>
        <span class="hljs-comment">// redefine the event.target.value with cleaned value.</span>
        <span class="hljs-keyword">const</span> newEvent = {
          ...event,
          <span class="hljs-attr">target</span>: { ...event.target, <span class="hljs-attr">value</span>: cleanValue }
        }
        <span class="hljs-comment">// We dispatch our event to parent `onChange`.</span>
        props.onChange(newEvent)
      }
    }
  })
</code></pre>
<p>Remember that as much as possible the component we create from another one must be compliant with the first one in its interface. It should accept the same properties with the same types.</p>
<p>Now if we want for instance to create a number field that will accept only digits, we can write:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> NumericField = forbidCharacters(<span class="hljs-regexp">/[^\d]/g</span>)(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &lt;input {...props} /&gt;)
</code></pre>
<p>We now have our first HOC to forbid some characters, now letâ€™s write the second one, a bit more complex, to format user input.</p>
<h2 id="second-hoc-format-input-value">Second HOC: format input value</h2>
<p>For our second HOC, weâ€™ll have to use a local inner state to store the input value without giving it to the encapsulating component. Remember we want to format the input value only when the focus is lost (<em>blur</em> event).</p>
<p>Recompose has a very simple function to add a local state to a component: <code>withState</code>. It takes as parameter the name of state attribute (that will be given as prop to child component), the name of the function prop to update this state attribute (also given as prop), and its initial value (static value, or a function taking props as parameter and returning the value).</p>
<p>To add our state weâ€™ll write:</p>
<pre><code class="lang-js">withState(
  <span class="hljs-string">'inputValue'</span>,
  <span class="hljs-string">'setInputValue'</span>,
  <span class="hljs-comment">// formatValue is one of our HOC parameters</span>
  props =&gt; formatValue(props.value)
)
</code></pre>
<p>Easy, right? ðŸ˜‰</p>
<p>Now that we have our state, we must use update it when the input value is changed, so weâ€™ll define a custom <code>onChange</code> handler:</p>
<pre><code class="lang-js">withHandlers({
  <span class="hljs-attr">onChange</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> event =&gt; {
    props.setInputValue(event.target.value)
  },
  <span class="hljs-comment">// ...</span>
</code></pre>
<p>And on <em>blur</em> event, weâ€™ll format the value, call parent <code>onChange</code> and <code>onBlur</code> props, and update the displayed value with for formatted value:</p>
<pre><code class="lang-js">  <span class="hljs-comment">// ...</span>
  onBlur: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> event =&gt; {
    <span class="hljs-comment">// parseValue is the other parameter of our HOC</span>
    <span class="hljs-keyword">const</span> parsedValue = parseValue(props.inputValue)
    <span class="hljs-keyword">const</span> formattedValue = formatValue(parsedValue)
    props.setInputValue(formattedValue)
    <span class="hljs-comment">// We donâ€™t mutate original event, but we clone it and</span>
    <span class="hljs-comment">// redefine the event.target.value with cleaned value.</span>
    <span class="hljs-keyword">const</span> newEvent = {
      ...event,
      <span class="hljs-attr">target</span>: { ...event.target, <span class="hljs-attr">value</span>: parsedValue }
    }
    <span class="hljs-keyword">if</span> (props.onChange) {
      props.onChange(newEvent)
    }
    <span class="hljs-keyword">if</span> (props.onBlur) {
      props.onBlur(newEvent)
    }
  }
)
</code></pre>
<p>The last step for our HOC is to ensure that only the props accepted by <code>&lt;input&gt;</code> component will be passed to it. To do so, weâ€™ll use Recomposeâ€™s <code>mapProps</code> function to create a new prop object from existing props, and also <em>lodash</em>â€™s <code>omit</code> function to exclude some properties from an object to create a new one:</p>
<pre><code class="lang-js">mapProps(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> ({
  ...omit(props, [<span class="hljs-string">'inputValue'</span>, <span class="hljs-string">'setInputValue'</span>]),
  <span class="hljs-attr">value</span>: props.inputValue
}))
</code></pre>
<p>Assembling everything with <code>compose</code>, weâ€™ll get:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> formatInputValue = <span class="hljs-function">(<span class="hljs-params">{ formatValue, parseValue }</span>) =&gt;</span>
  compose(
    withState(<span class="hljs-string">'inputValue'</span>, <span class="hljs-string">'setInputValue'</span>, props =&gt; formatValue(props.value)),
    withHandlers({
      <span class="hljs-attr">onChange</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> event =&gt; {
        props.setInputValue(event.target.value)
      },
      <span class="hljs-attr">onBlur</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> event =&gt; {
        <span class="hljs-keyword">const</span> parsedValue = parseValue(props.inputValue)
        <span class="hljs-keyword">const</span> formattedValue = formatValue(parsedValue)
        props.setInputValue(formattedValue)
        <span class="hljs-keyword">const</span> newEvent = {
          ...event,
          <span class="hljs-attr">target</span>: { ...event.target, <span class="hljs-attr">value</span>: parsedValue }
        }
        <span class="hljs-keyword">if</span> (props.onChange) {
          props.onChange(newEvent)
        }
        <span class="hljs-keyword">if</span> (props.onBlur) {
          props.onBlur(newEvent)
        }
      }
    }),
    mapProps(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> ({
      ...omit(props, [<span class="hljs-string">'inputValue'</span>, <span class="hljs-string">'setInputValue'</span>]),
      <span class="hljs-attr">value</span>: props.inputValue
    }))
  )
</code></pre>
<p>Thatâ€™s it! We have our two high-order components, we can use them to create our phone input field component! Below you can find the JSFiddle containing the complete source code for this example, and test the result. Donâ€™t hesitate to fork the <a href="https://jsfiddle.net/scastiel/prme4k6L/">JSFiddle</a> to play with Recompose or create your own high-order components.</p>
<iframe width="100%" height="300" src="//jsfiddle.net/scastiel/prme4k6L/8/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>I hope this article made you want to know more about Recompose and high-order components in general. Iâ€™m convinced HOCs create a new way to write reusable components; no doubt weâ€™ll here about them more and more in the future ðŸ˜€.</p>
<p>Some ressources to go further:</p>
<ul>
<li><a href="https://github.com/acdlite/recompose/blob/master/docs/API.md">Recompose API documentation</a> is quite complete, although in my opinion it lacks some example to understand some complexe functions;</li>
<li><a href="https://reactjs.org/docs/higher-order-components.html">React page about HOCs</a> contains a lot of information, for instance what you shouldnâ€™t do with HOCS ðŸ˜‰</li>
<li><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e">React Higher Order Components in depth</a>: a great introduction to HOCs</li>
<li><a href="https://medium.com/javascript-inside/why-the-hipsters-recompose-everything-23ac08748198">Why The Hipsters Recompose Everything</a>: a cool intro to concepts of Recompose (seems a little outdatedâ€¦)</li>
</ul>
</div></article><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = 'https://blog.castiel.me/posts/006-reusable-hoc-with-recompose';  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = '006-reusable-hoc-with-recompose'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//blog-castiel-me.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script><footer class="blog-footer"><p>All content distributed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license. Powered by <a href="https://github.com/scastiel/miblog">Miblog</a>.</p>
</footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-86441091-1', 'auto');
ga('send', 'pageview');</script></body></html>