<!DOCTYPE html><html><head><title>Use the coolest ES6 features everywhere – Another webdev blog</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="https://blog.castiel.me/css/app.css"><link rel="alternate" type="application/rss+xml" title="Another webdev blog" href="https://blog.castiel.me/rss.xml"></head><body><header class="blog-header"><h1 class="blog-title"><a href="https://blog.castiel.me/">Another webdev blog</a></h1><div class="blog-description"><p>I&#39;m <a href="https://twitter.com/scastiel">Sébastien Castiel</a>, and I talk about web development and some other stuff.</p>
</div></header><article><header><h2><a href="https://blog.castiel.me/posts/002-use-the-coolest-es6-features-everywhere.html">Use the coolest ES6 features everywhere</a></h2><div class="infos"><time datetime="2016-11-02T14:19:00.000Z">Nov 2, 2016</time></div></header><div class="content"><p>If you use JavaScript you probably know that recently a lot of new features arrived with ES2015 (also known as ES6): classes, <code>const</code>/<code>let</code> keywords, destructuring arrays and objects, modules and imports, etc.</p>
<p>You also probably know that all these features are not currently available in all browsers. A very good way to know how one particular feature is supported in all browsers is this <a href="http://kangax.github.io/compat-table/es2016plus/">ECMAScript 6 compatibility table</a>. Looking at this table, you can think that it’s probably better not to use certain ES6 features because it can crash on some browsers. And what about Node.js? Are these features implemented? In which version?</p>
<p>That’s where a fantastic tool makes sense: Babel. And I’m gonna show you how to use it both client-side and server-side, so you’ll be able to play with latest JavaScript features right now.</p>
<!--readmore-->
<p>I’ll suppose you have a simple project, with a front-end and a back-end (in Node.js). To keep this example the simplest possible, I’ll try to use only really necessary tools. So no Webpack, no Grunt, only <em>npm</em> scripts to build and start the project.</p>
<h2 id="our-example-webapp">Our example webapp</h2>
<p>Let’s start from a really simple webapp. It’s served from a single file in the backend, <em>src/server/app.js</em>:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// src/server/app.js</span>
<span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> app = express();

app.use(express.static(__dirname + <span class="hljs-string">'/../../public'</span>));

app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Example app listening on port 3000!'</span>);
});
</code></pre>
<p>For the front-end part, we&#39;ll have an <em>index.html</em> file in the <em>public</em> directory:</p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- public/index.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"result"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/app.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>And a JavaScript file, <em>public/lib/app.js</em>:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// public/js/app.js</span>
<span class="hljs-keyword">var</span> o1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">var</span> o2 = { <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">4</span> };
<span class="hljs-keyword">var</span> o3 = <span class="hljs-built_in">Object</span>.assign({}, o1, o2); <span class="hljs-comment">// put o1 and o2 properties into a new object o3</span>
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'result'</span>).innerHTML = <span class="hljs-built_in">JSON</span>.stringify(o3);
</code></pre>
<p>Your directory should look like this:</p>
<pre><code>+ public/
  + js/
    + app<span class="hljs-selector-class">.js</span>
  + index<span class="hljs-selector-class">.html</span>
+ src/
  + server/
    + app.js
</code></pre><p>As you can see, this application is very useless. We expect that in the browser when opening <code>http://localhost:3000/index.html</code>, we get a webpage that will show exactly <code>{&quot;a&quot;:1,&quot;b&quot;:3,&quot;c&quot;:4}</code>.</p>
<p>To run this example, you can first initialize your app with a new <em>package.json</em> (<code>npm init</code>), then install <code>express</code> (<code>npm i --save express</code>), and add an <em>npm</em> script to start the app in the <em>package.json</em>:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// ...</span>
<span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"start"</span>: <span class="hljs-string">"node src/server/app.js"</span>
}
<span class="hljs-comment">// ...</span>
</code></pre>
<p>Then start the application by running: <code>npm start</code></p>
<p>Here is why we want to use Babel:</p>
<ul>
<li>in the back-end, we want to import <em>express</em> as an ES6 module with: <code>import express from &#39;express&#39;</code></li>
<li>in the front-end, we want use object spread operator: <code>var o3 = { ...o1, ...o2 }</code></li>
</ul>
<p>Again notice this is not very useful, but we need Babel to use this two ES6 features that are not available by default.</p>
<h2 id="meet-babel">Meet Babel</h2>
<p>Although there are several ways to use Babel, we&#39;ll use it as a command line tool. Basically, it takes as parameter a JavaScript file, and produces a new file created from the first one, but with all ES6 (and next) features replaced with ES5 (classical JavaScript) equivalent. It&#39;s called transpilation (compilation from a language from another).</p>
<p>To install Babel, run: <code>npm i --save-dev babel-cli babel-preset-latest babel-preset-stage-0</code>. The first package is the command line tool, and the second and third ones contain the language features we want. <code>stage-0</code> contains the more recent (and potentially not definitive) features.</p>
<p>Create a <em>.babelrc</em> file, containing: <code>{ &quot;presets&quot;: [&quot;latest&quot;, &quot;stage-0&quot;] }</code>. It will say to Babel command line tool that we want to use the features we just installed.</p>
<h3 id="for-the-front-end">For the front-end</h3>
<p>The first step is to put our front-end JavaScript file <em>(public/js/app.js)</em> in another directory. Let&#39;s put this <em>app.js</em> file into <em>src/client</em> directory (and delete the <em>public/js</em> directory), and change its content to:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// src/client/app.js</span>
<span class="hljs-keyword">var</span> o1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">var</span> o2 = { <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">4</span> };
<span class="hljs-keyword">var</span> o3 = { ... o1, ... o2 }; <span class="hljs-comment">// put o1 and o2 properties into a new object o3</span>
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'result'</span>).innerHTML = <span class="hljs-built_in">JSON</span>.stringify(o3);
</code></pre>
<p>Now we must call Babel command line tool to generate the “not-ES6” version of this file. To make things clean, let&#39;s create a new <em>npm</em> script:</p>
<pre><code class="lang-javascript"><span class="hljs-string">"scripts"</span>: {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">"build:client"</span>: <span class="hljs-string">"babel src/client -d dist/client"</span>
}
</code></pre>
<p>Let&#39;s modify a little our <em>src/server/app.js</em> to make it look for our JavaScript file in the right directory:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// src/server/app.js</span>
<span class="hljs-comment">// ...</span>
app.use(express.static(__dirname + <span class="hljs-string">'/../../public'</span>));
app.use(<span class="hljs-string">'/js'</span>, express.static(__dirname + <span class="hljs-string">'/../../dist/client'</span>));
<span class="hljs-comment">// ...</span>
</code></pre>
<p>By running <code>npm run build:client</code>, you should obtain a new <em>app.js</em> file in <em>dist/client</em> directory. Notice that it&#39;s not that different from out first version ;)</p>
<p>Then try to run the app with <code>npm start</code>, it still should work!</p>
<h3 id="for-the-back-end">For the back-end</h3>
<p>In our <em>src/server/app.js</em> file, we want to use ES6 module system. Let&#39;s edit our file (the first line):</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// src/server/app.js</span>
<span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;
</code></pre>
<p>Using Babel for the back-end of our application is not difficult either. Just add a <em>npm</em> script and update the existing <em>start</em> script:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// package.json</span>
<span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"start"</span>: <span class="hljs-string">"node dist/server/app.js"</span>,
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">"build:server"</span>: <span class="hljs-string">"babel src/server -d dist/server"</span>
}
</code></pre>
<p>You guessed it, the command <code>npm run build:server</code> will create a new <em>dist/server</em> directory with an <em>app.js</em> file. And the <code>npm start</code> command still starts the app correctly :)</p>
<p><strong>Note:</strong> it&#39;s a good idea to put all generated files into a single directory (here <em>dist</em>). This way you can ignore this directory with the versionning tool you use (put it into ths <em>.gitignore</em> for Git for instance).</p>
<hr>
<p>You&#39;ve done it! Now you can write all your JavaScript, both back-end and front-end, using the last language features: <code>async</code>/<code>await</code> (cool article <a href="https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-deserved.html">here</a>), object destructuring (good introduction <a href="http://exploringjs.com/es6/ch_destructuring.html">here</a>), and a lot of other stuff!</p>
<p>By the way, the example app for this article is <a href="https://github.com/scastiel/hello-babel">available on GitHub</a> :)</p>
<p>To go further:</p>
<ul>
<li>Using <a href="https://webpack.github.io/">Webpack</a> can really change your life when dealing with large front-end applications with several JavaScript files, and of course using Babel with it is supported.</li>
<li><a href="http://babeljs.io/docs/plugins/">Babel website</a> lists all available language features and which <em>preset</em> you must install to use them.</li>
</ul>
</div></article><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = 'https://blog.castiel.me/posts/002-use-the-coolest-es6-features-everywhere';  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = '002-use-the-coolest-es6-features-everywhere'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//blog-castiel-me.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script><footer class="blog-footer"><p>All content distributed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license. Powered by <a href="https://github.com/scastiel/miblog">Miblog</a>.</p>
</footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-86441091-1', 'auto');
ga('send', 'pageview');</script></body></html>